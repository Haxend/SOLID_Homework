# Деонстрация работы SOLID принципов
## Цель:
На примере реализации игры «Угадай число» продемонстрировать практическое применение SOLID принципов.
Программа рандомно генерирует число, пользователь должен угадать это число. При каждом вводе числа программа пишет больше или меньше отгадываемого. Кол-во попыток отгадывания и диапазон чисел должен задаваться из настроек.
В отчёте написать, что именно сделано по каждому принципу.
Приложить ссылку на проект и написать, сколько времени ушло на выполнение задачи.

## SOLID
### S - Single responsibility principle
Классы: Checker, Generator, Messager, Setting каждый из них выполняет одну функию

### O - Open/Close principle
Классы Generator, Checker закрывает доступ к собственной модификаци, но открыты для изменения метода генерации числа (GenerateNewValue)
Продемонстировано в классах GeneratorLiskov

### L - Liskov substitution principle
Класс GeneratorLiskov расширяет функционал класса родителя GeneratorLiskov.
При этом сохраняется оригинальное поведение, в любом месте, где это требуется, можно использовать
GeneratorLiskov вместо его родителя и получить "ожидаемый" результат.

### I - Interface segregation principle:
Все интерфейсы сожержат минимум требований для реализации, необходимый для функционирования классов наследников.
Например IMessage требует реализовать восемь методов, которые нужны для класса NumberGuesser
для чего и был создан данный интерфейс.

### D - Dependency inversion principle
Во всех классах, все зависимости сделаны на интерфейсы, что позволяет абстрагироваться от реализации, т.е. зависеть от абстракций.
